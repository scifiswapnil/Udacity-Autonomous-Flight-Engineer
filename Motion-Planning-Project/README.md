## Project: 3D Motion Planning

## [Project Rubric](https://review.udacity.com/#!/rubrics/1534/view)
### Here I have addressed each point in my implementation.

### README

#### 1. Provide a Writeup / README that includes all the rubric points and how you addressed each one. You can submit your writeup as markdown or pdf.

You're reading it! Below I describe how I addressed each rubric point and where in my code each point is handled.

### Explain the Starter Code

#### 1. Explain the functionality of what's provided in `motion_planning.py` and `planning_utils.py`
These scripts contain a basic planning implementation that includes:
1. `planning_utils_solution.py`:
    1. `create_grid(data, drone_altitude, safety_distance)`:
        Returns a 2D grid representation of the configuration space given obstacles defined in *data* and based on *drone_altitude* and *safety_distance* arguments. The obstacles are padded in all directions (up, north, south, west, east) by *safety_distance*.

    2. `Action`:
        Defines possible navigation actions. Actions are defined as tupples where the first 2 values are the delta of the action relative to the current position, and the third value is the cost of performing the action.
        
        `Action` class methods:
                
            cost: returns the cost of performing the action.
            delta: returns the delata of the action relative to the current position.
        
    3. `valid_actions(grid, current_node)`:
        Returns a list of valid actions given a *grid* and *current_node* arguments by checking obstacles on the *grid*.

    4. `a_star(grid, h, start, goal)`:
        Returns a path between the *start* and *goal* by implementing A\* algorithm over given *gird* and using heuristic function, *h*. 

    5. `heuristic(position, goal_position)`:
        Returns the heuristic cost for the path from *position* to *goal_position* arguments.

    6.  `prune_paths`:
        Takes input the path generated by the a_start algorithm and prunes the path to minimise the number of waypoints in the path. 
        
2. `motion_planning_solution.py`:
    - `motion_planning_solution.py` is an extension to `backyard_flyer_solution.py`, in which a new `plan_path` method and `PLANNING` state are added to incorporate path planning methods (here A\*) to find a path from start to goal positions.
    Path planning occurs after arming and before take off. Once armed, `plan_path` method is called to generate a path (a lits of waypoints) and the flying state transients to `PLANNING` state, at which the drone takes off and follows waypoints. 

**Test Result:** Here is the results:

A) Running `backyard_flyer_solution.py` script : 

![Backyard Solution Test](gifs/output1.gif)

B) Running `motion_planning.py` script :  

![Motion Planning Script Test](gifs/output2.gif)

### Implementing Your Path Planning Algorithm

#### 1. Set your global home position
The `lat0` and `lon0` values are extracted and then home position is set based on the `lat0` and `lon0` values:

```python

with open(self.map_file, newline='') as f:
            reader = csv.reader(f)
            row1 = next(reader)

self.set_home_position(float(row1[1].strip(' lon0')),
                        float(row1[0].strip('lat0')),
                        0.0)
```

#### 2. Set your current local position
`global_to_local` method, which converts a global position to a local position relative to the home position:
```python
local_position = global_to_local(self.global_position, self.global_home)
```

#### 3. Set grid start position from local position
This is done by appling the north and east offsets to the local position to get the start location on the grid:
```python
grid_start=(int(local_position[0])-north_offset,int(local_position[1]) -east_offset)
```

#### 4. Set grid goal position from geodetic coords
This is done by using `global_to_local` method to convert any `(lat, lon)` within the map to a position relative to the global home position, subsequently the goal position on the grid is set by applying the offsets.
```python
goal_position = global_to_local(goal_coordinate, self.global_home)
print('global goal position {}'.format(goal_position))

grid_goal = (int(goal_position[0])-north_offset, int(goal_position[1])-east_offset)
```

This part is tested by selecting a random position around local position, but any set of `(lat, lon)` works as well:
```python
converage_radius = 50
random_goal_coordinate = local_to_global([local_position[0]+random.uniform(-converage_radius, converage_radius),
                local_position[1]+random.uniform(-converage_radius, converage_radius),
                0.0], self.global_home)

goal_coordinate = random_goal_coordinate
```

#### 5. Modify A* to include diagonal motion (or replace A* altogether)
This is done by modifying `planning_utils_solution.py` script. To complete this part, first a set of diagonal actions are defined in `Action` class as follows:
```python
class Action(Enum):

    ...
    WEST_NORTH = (-1, -1, np.sqrt(2))
    WEST_SOUTH = (1, -1, np.sqrt(2))
    EAST_NORTH = (-1, 1, np.sqrt(2))
    EAST_SOUTH = (1, 1, np.sqrt(2))
    
    ...
```

Then `valid_actions` method is modified to check the feasibility of diagonal actions:
```python
if x - 1 < 0 or y - 1 < 0 or grid[x - 1, y - 1] == 1:
    valid_actions.remove(Action.WEST_NORTH)
if x + 1 > n or y - 1 < 0 or grid[x + 1, y - 1] == 1:
    valid_actions.remove(Action.WEST_SOUTH)
if x - 1 < 0 or y + 1 > m or grid[x - 1, y + 1] == 1:
    valid_actions.remove(Action.EAST_NORTH)
if x + 1 > n or y +1 > m or grid[x + 1, y + 1] == 1:
    valid_actions.remove(Action.EAST_SOUTH)
```

#### 6. prune waypoints 
For this step, a 2D collinearity test is implemented to prune the path. In each step, three consecutive points `(p1,p2,p3)` on the path is tested against collinearity. For each test, there are two cases:
- If collinear, `p2` is excluded, and test is continued for `p1`, `p3`, and the next point on the path. 
- If not collinear, `p1` is added to the proned path, and test is continued for `p2`, `p3`, and the next point on the path.

```python
def is_collinear(p1, p2, p3): 
    det = p1[0]*(p2[1] - p3[1]) + p2[0]*(p3[1] - p1[1]) + p3[0]*(p1[1] - p2[1])
    if det == 0:
        return True
    return False
pruned_path = []
if len(path) >= 3:
    p1 = path[0]
    p2 = path[1]
    p3 = path[2]
    i = 2
    while i < (len(path) - 1):
        while is_collinear(p1,p2,p3) and (i < len(path)-2):
            i += 1
            p2 = p3
            p3 = path[i]
        pruned_path.append(p1)
        p1 = p2
        p2 = p3
        i += 1
        p3 = path[i]
    pruned_path.append(p2)
    pruned_path.append(p3)
else:
    pruned_path = path
waypoints = [[p[0] + north_offset, p[1] + east_offset, TARGET_ALTITUDE, 0] for p in pruned_path]
```

### Execute the flight
#### 1. Does it work?
It works!

![Motion Planning Demo](gifs/output3.gif)

### Double check that you've met specifications for each of the [rubric](https://review.udacity.com/#!/rubrics/1534/view) points.

# Extra Challenges: Real World Planning

I plan to implement this section later the end of the course.
